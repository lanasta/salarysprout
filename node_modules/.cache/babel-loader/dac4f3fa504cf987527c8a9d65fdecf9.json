{"ast":null,"code":"var english = require(\"./wordlists/english\");\n\nvar nacl = require(\"../nacl/naclWrappers\");\n\nvar ERROR_FAIL_TO_DECODE_MNEMONIC = Error('failed to decode mnemonic');\nvar ERROR_NOT_IN_WORDS_LIST = Error('the mnemonic contains a word that is not in the wordlist');\n/**\n * mnemonicFromSeed converts a 32-byte key into a 25 word mnemonic. The generated mnemonic includes a checksum.\n * Each word in the mnemonic represents 11 bits of data, and the last 11 bits are reserved for the checksum.\n * @param seed 32 bytes long seed\n * @returns {string} 25 words mnemonic\n */\n\nfunction mnemonicFromSeed(seed) {\n  // Sanity length check\n  if (seed.length !== nacl.SEED_BTYES_LENGTH) {\n    throw new RangeError(\"Seed length must be \" + nacl.SEED_BTYES_LENGTH);\n  }\n\n  var uint11Array = toUint11Array(seed);\n  var words = applyWords(uint11Array);\n  var checksumWord = computeChecksum(seed);\n  return words.join(' ') + ' ' + checksumWord;\n}\n/**\n * seedFromMnemonic converts a mnemonic generated using this library into the source key used to create it.\n * It returns an error if the passed mnemonic has an incorrect checksum, if the number of words is unexpected, or if one\n * of the passed words is not found in the words list.\n * @param mnemonic 25 words mnemonic\n * @returns {Uint8Array} 32 bytes long seed\n */\n\n\nfunction seedFromMnemonic(mnemonic) {\n  var words = mnemonic.split(' ');\n  var key = words.slice(0, 24); //Check that all words are in list\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = key[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var w = _step.value;\n      if (english.indexOf(w) === -1) throw ERROR_NOT_IN_WORDS_LIST;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var checksum = words[words.length - 1];\n  var uint11Array = key.map(function (word) {\n    return english.indexOf(word);\n  }); // Convert the key to uint8Array\n\n  var uint8Array = toUint8Array(uint11Array); // We need to chop the last byte -\n  // the short explanation - Since 256 is not divisible by 11, we have an extra 0x0 byte.\n  // The longer explanation - When splitting the 256 bits to chunks of 11, we get 23 words and a left over of 3 bits.\n  // This left gets padded with another 8 bits to the create the 24th word.\n  // While converting back to byte array, our new 264 bits array is divisible by 8 but the last byte is just the padding.\n  // check that we have 33 bytes long array as expected\n\n  if (uint8Array.length !== 33) throw ERROR_FAIL_TO_DECODE_MNEMONIC; // check that the last byte is actually 0x0\n\n  if (uint8Array[uint8Array.length - 1] !== 0x0) throw ERROR_FAIL_TO_DECODE_MNEMONIC; // chop it !\n\n  uint8Array = uint8Array.slice(0, uint8Array.length - 1); // compute checksum\n\n  var cs = computeChecksum(uint8Array); // success!\n\n  if (cs === checksum) return uint8Array;\n  throw ERROR_FAIL_TO_DECODE_MNEMONIC;\n}\n\nfunction computeChecksum(seed) {\n  var hashBuffer = nacl.genericHash(seed);\n  var uint11Hash = toUint11Array(hashBuffer);\n  var words = applyWords(uint11Hash);\n  return words[0];\n}\n\nfunction applyWords(nums) {\n  return nums.map(function (n) {\n    return english[n];\n  });\n} // https://stackoverflow.com/a/51452614\n\n\nfunction toUint11Array(buffer8) {\n  var buffer11 = [];\n  var acc = 0;\n  var accBits = 0;\n\n  function add(octet) {\n    acc = octet << accBits | acc;\n    accBits += 8;\n\n    if (accBits >= 11) {\n      buffer11.push(acc & 0x7ff);\n      acc >>= 11;\n      accBits -= 11;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer11.push(acc);\n    }\n  }\n\n  buffer8.forEach(add);\n  flush();\n  return buffer11;\n} // from Uint11Array\n// https://stackoverflow.com/a/51452614\n\n\nfunction toUint8Array(buffer11) {\n  var buffer8 = [];\n  var acc = 0;\n  var accBits = 0;\n\n  function add(ui11) {\n    acc = ui11 << accBits | acc;\n    accBits += 11;\n\n    while (accBits >= 8) {\n      buffer8.push(acc & 0xff);\n      acc >>= 8;\n      accBits -= 8;\n    }\n  }\n\n  function flush() {\n    if (accBits) {\n      buffer8.push(acc);\n    }\n  }\n\n  buffer11.forEach(add);\n  flush();\n  return new Uint8Array(buffer8);\n}\n\nmodule.exports = {\n  mnemonicFromSeed: mnemonicFromSeed,\n  seedFromMnemonic: seedFromMnemonic,\n  ERROR_FAIL_TO_DECODE_MNEMONIC: ERROR_FAIL_TO_DECODE_MNEMONIC,\n  ERROR_NOT_IN_WORDS_LIST: ERROR_NOT_IN_WORDS_LIST\n};","map":null,"metadata":{},"sourceType":"script"}
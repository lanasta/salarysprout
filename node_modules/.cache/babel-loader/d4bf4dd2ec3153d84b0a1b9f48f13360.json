{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar client = require('./client');\n\nvar txn = require(\"../transaction\");\n\nfunction Kmd(token) {\n  var baseServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"http://127.0.0.1\";\n  var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7833;\n  // Get client\n  var c = new client.HTTPClient({\n    'X-KMD-API-Token': token\n  }, baseServer, port);\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   * @returns {Promise<*>}\n   */\n\n  this.versions =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return c.get(\"/versions\");\n\n          case 2:\n            res = _context.sent;\n            return _context.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   * @returns {Promise<*>}\n   */\n\n  this.listWallets =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return c.get(\"/v1/wallets\");\n\n          case 2:\n            res = _context2.sent;\n            return _context2.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   * @returns {Promise<*>}\n   */\n\n  this.createWallet =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(walletName, walletPassword) {\n      var walletMDK,\n          walletDriverName,\n          req,\n          res,\n          _args3 = arguments;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              walletMDK = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : \"\";\n              walletDriverName = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : \"sqlite\";\n              req = {\n                \"wallet_name\": walletName,\n                \"wallet_driver_name\": walletDriverName,\n                \"wallet_password\": walletPassword,\n                \"master_derivation_key\": Buffer.from(walletMDK).toString('base64')\n              };\n              _context3.next = 5;\n              return c.post(\"/v1/wallet\", req);\n\n            case 5:\n              res = _context3.sent;\n              return _context3.abrupt(\"return\", res.body);\n\n            case 7:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x, _x2) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.initWalletHandle =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(walletID, walletPassword) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              req = {\n                \"wallet_id\": walletID,\n                \"wallet_password\": walletPassword\n              };\n              _context4.next = 3;\n              return c.post(\"/v1/wallet/init\", req);\n\n            case 3:\n              res = _context4.sent;\n              return _context4.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x3, _x4) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.releaseWalletHandle =\n  /*#__PURE__*/\n  function () {\n    var _ref5 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle\n              };\n              _context5.next = 3;\n              return c.post(\"/v1/wallet/release\", req);\n\n            case 3:\n              res = _context5.sent;\n              return _context5.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n\n    return function (_x5) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.renewWalletHandle =\n  /*#__PURE__*/\n  function () {\n    var _ref6 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle\n              };\n              _context6.next = 3;\n              return c.post(\"/v1/wallet/renew\", req);\n\n            case 3:\n              res = _context6.sent;\n              return _context6.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n\n    return function (_x6) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   * @returns {Promise<*>}\n   */\n\n\n  this.renameWallet =\n  /*#__PURE__*/\n  function () {\n    var _ref7 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(walletID, walletPassword, newWalletName) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              req = {\n                \"wallet_id\": walletID,\n                \"wallet_password\": walletPassword,\n                \"wallet_name\": newWalletName\n              };\n              _context7.next = 3;\n              return c.post(\"/v1/wallet/rename\", req);\n\n            case 3:\n              res = _context7.sent;\n              return _context7.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x7, _x8, _x9) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.getWallet =\n  /*#__PURE__*/\n  function () {\n    var _ref8 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle\n              };\n              _context8.next = 3;\n              return c.post(\"/v1/wallet/info\", req);\n\n            case 3:\n              res = _context8.sent;\n              return _context8.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    return function (_x10) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMasterDerivationKey =\n  /*#__PURE__*/\n  function () {\n    var _ref9 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(walletHandle, walletPassword) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"wallet_password\": walletPassword\n              };\n              _context9.next = 3;\n              return c.post(\"/v1/master-key/export\", req);\n\n            case 3:\n              res = _context9.sent;\n              return _context9.abrupt(\"return\", {\n                \"master_derivation_key\": Buffer.from(res.body.master_derivation_key, 'base64')\n              });\n\n            case 5:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n\n    return function (_x11, _x12) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   * @returns {Promise<*>}\n   */\n\n\n  this.importKey =\n  /*#__PURE__*/\n  function () {\n    var _ref10 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee10(walletHandle, secretKey) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"private_key\": Buffer.from(secretKey).toString('base64')\n              };\n              _context10.next = 3;\n              return c.post(\"/v1/key/import\", req);\n\n            case 3:\n              res = _context10.sent;\n              return _context10.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n\n    return function (_x13, _x14) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportKey =\n  /*#__PURE__*/\n  function () {\n    var _ref11 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee11(walletHandle, walletPassword, addr) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"address\": addr,\n                \"wallet_password\": walletPassword\n              };\n              _context11.next = 3;\n              return c.post(\"/v1/key/export\", req);\n\n            case 3:\n              res = _context11.sent;\n              return _context11.abrupt(\"return\", {\n                \"private_key\": Buffer.from(res.body.private_key, 'base64')\n              });\n\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, _callee11);\n    }));\n\n    return function (_x15, _x16, _x17) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.generateKey =\n  /*#__PURE__*/\n  function () {\n    var _ref12 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee12(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"display_mnemonic\": false\n              };\n              _context12.next = 3;\n              return c.post(\"/v1/key\", req);\n\n            case 3:\n              res = _context12.sent;\n              return _context12.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee12);\n    }));\n\n    return function (_x18) {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteKey =\n  /*#__PURE__*/\n  function () {\n    var _ref13 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee13(walletHandle, walletPassword, addr) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"address\": addr,\n                \"wallet_password\": walletPassword\n              };\n              _context13.next = 3;\n              return c.delete(\"/v1/key\", req);\n\n            case 3:\n              res = _context13.sent;\n              return _context13.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    }));\n\n    return function (_x19, _x20, _x21) {\n      return _ref13.apply(this, arguments);\n    };\n  }();\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listKeys =\n  /*#__PURE__*/\n  function () {\n    var _ref14 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee14(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle\n              };\n              _context14.next = 3;\n              return c.post(\"/v1/key/list\", req);\n\n            case 3:\n              res = _context14.sent;\n              return _context14.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, _callee14);\n    }));\n\n    return function (_x22) {\n      return _ref14.apply(this, arguments);\n    };\n  }();\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @returns {Promise<*>}\n   */\n\n\n  this.signTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref15 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee15(walletHandle, walletPassword, transaction) {\n      var tx, req, res;\n      return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              tx = new txn.Transaction(transaction);\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"wallet_password\": walletPassword,\n                \"transaction\": tx.toByte().toString('base64')\n              };\n              _context15.next = 4;\n              return c.post(\"/v1/transaction/sign\", req);\n\n            case 4:\n              res = _context15.sent;\n\n              if (!(res.statusCode === 200)) {\n                _context15.next = 7;\n                break;\n              }\n\n              return _context15.abrupt(\"return\", Buffer.from(res.body.signed_transaction, 'base64'));\n\n            case 7:\n              return _context15.abrupt(\"return\", res.body);\n\n            case 8:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, _callee15);\n    }));\n\n    return function (_x23, _x24, _x25) {\n      return _ref15.apply(this, arguments);\n    };\n  }();\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   * @returns {Promise<*>}\n   */\n\n\n  this.listMultisig =\n  /*#__PURE__*/\n  function () {\n    var _ref16 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee16(walletHandle) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle\n              };\n              _context16.next = 3;\n              return c.post(\"/v1/multisig/list\", req);\n\n            case 3:\n              res = _context16.sent;\n              return _context16.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, _callee16);\n    }));\n\n    return function (_x26) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   * @returns {Promise<*>}\n   */\n\n\n  this.importMultisig =\n  /*#__PURE__*/\n  function () {\n    var _ref17 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee17(walletHandle, version, threshold, pks) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"multisig_version\": version,\n                \"threshold\": threshold,\n                \"pks\": pks\n              };\n              _context17.next = 3;\n              return c.post(\"/v1/multisig/import\", req);\n\n            case 3:\n              res = _context17.sent;\n              return _context17.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, _callee17);\n    }));\n\n    return function (_x27, _x28, _x29, _x30) {\n      return _ref17.apply(this, arguments);\n    };\n  }();\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.exportMultisig =\n  /*#__PURE__*/\n  function () {\n    var _ref18 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee18(walletHandle, addr) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"address\": addr\n              };\n              _context18.next = 3;\n              return c.post(\"/v1/multisig/export\", req);\n\n            case 3:\n              res = _context18.sent;\n              return _context18.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, _callee18);\n    }));\n\n    return function (_x31, _x32) {\n      return _ref18.apply(this, arguments);\n    };\n  }();\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   * @returns {Promise<*>}\n   */\n\n\n  this.signMultisigTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref19 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee19(walletHandle, pw, transaction, pk, partial) {\n      var tx, req, res;\n      return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              tx = new txn.Transaction(transaction);\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"transaction\": tx.toByte().toString('base64'),\n                \"public_key\": Buffer.from(pk).toString('base64'),\n                \"partial_multisig\": partial,\n                \"wallet_password\": pw\n              };\n              _context19.next = 4;\n              return c.post(\"/v1/multisig/sign\", req);\n\n            case 4:\n              res = _context19.sent;\n              return _context19.abrupt(\"return\", res.body);\n\n            case 6:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n      }, _callee19);\n    }));\n\n    return function (_x33, _x34, _x35, _x36, _x37) {\n      return _ref19.apply(this, arguments);\n    };\n  }();\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the \n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   * @returns {Promise<*>}\n   */\n\n\n  this.deleteMultisig =\n  /*#__PURE__*/\n  function () {\n    var _ref20 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee20(walletHandle, walletPassword, addr) {\n      var req, res;\n      return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              req = {\n                \"wallet_handle_token\": walletHandle,\n                \"address\": addr,\n                \"wallet_password\": walletPassword\n              };\n              _context20.next = 3;\n              return c.delete(\"/v1/multisig\", req);\n\n            case 3:\n              res = _context20.sent;\n              return _context20.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, _callee20);\n    }));\n\n    return function (_x38, _x39, _x40) {\n      return _ref20.apply(this, arguments);\n    };\n  }();\n}\n\nmodule.exports = {\n  Kmd: Kmd\n};\nmodule.exports = {\n  Kmd: Kmd\n};","map":null,"metadata":{},"sourceType":"script"}
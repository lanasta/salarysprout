{"ast":null,"code":"var _classCallCheck = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar nacl = require('./nacl/naclWrappers');\n\nvar address = require('./encoding/address');\n\nvar encoding = require('./encoding/encoding');\n\nvar txnBuilder = require('./transaction');\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\n\nvar ERROR_MULTISIG_MERGE_LESSTHANTWO = new Error(\"Not enough multisig transactions to merge. Need at least two\");\nvar ERROR_MULTISIG_MERGE_MISMATCH = new Error(\"Cannot merge txs. txIDs differ\");\nvar ERROR_MULTISIG_MERGE_WRONG_PREIMAGE = new Error(\"Cannot merge txs. Multisig preimages differ\");\nvar ERROR_MULTISIG_MERGE_SIG_MISMATCH = new Error(\"Cannot merge txs. subsigs are mismatched.\");\nvar ERROR_MULTISIG_BAD_FROM_FIELD = new Error(\"The transaction from field and multisig preimage do not match.\");\nvar ERROR_MULTISIG_KEY_NOT_EXIST = new Error(\"Key does not exist\");\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\n\nvar MultisigTransaction =\n/*#__PURE__*/\nfunction (_txnBuilder$Transacti) {\n  \"use strict\";\n\n  _inherits(MultisigTransaction, _txnBuilder$Transacti);\n\n  function MultisigTransaction() {\n    _classCallCheck(this, MultisigTransaction);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MultisigTransaction).apply(this, arguments));\n  }\n\n  _createClass(MultisigTransaction, [{\n    key: \"get_obj_for_encoding\",\n    value: function get_obj_for_encoding() {\n      if (this.hasOwnProperty(\"objForEncoding\")) {\n        // if set, use the value for encoding. This allows us to sign existing non-payment type transactions.\n        return this.objForEncoding;\n      }\n\n      return _get(_getPrototypeOf(MultisigTransaction.prototype), \"get_obj_for_encoding\", this).call(this);\n    }\n  }, {\n    key: \"partialSignTxn\",\n\n    /**\n     * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n     * encoded with msgpack as a typed array.\n     * @param version multisig version\n     * @param threshold multisig threshold\n     * @param pks multisig public key list, order is important.\n     * @param sk an Algorand secret key to sign with.\n     * @returns an encoded, partially signed multisig transaction.\n     */\n    value: function partialSignTxn(_ref, sk) {\n      var version = _ref.version,\n          threshold = _ref.threshold,\n          pks = _ref.pks;\n\n      // verify one more time that the from field is correct\n      if (!this.hasOwnProperty(\"objForEncoding\")) {\n        var expectedFromRaw = address.fromMultisigPreImg({\n          version: version,\n          threshold: threshold,\n          pks: pks\n        });\n\n        if (address.encode(this.from.publicKey) !== address.encode(expectedFromRaw)) {\n          throw ERROR_MULTISIG_BAD_FROM_FIELD;\n        }\n      } // get signature verifier\n\n\n      var myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n      return createMultisigTransaction(this.get_obj_for_encoding(), {\n        \"rawSig\": this.rawSignTxn(sk),\n        myPk: myPk\n      }, {\n        version: version,\n        threshold: threshold,\n        pks: pks\n      });\n    }\n  }], [{\n    key: \"from_obj_for_encoding\",\n    value: function from_obj_for_encoding(txnForEnc) {\n      if (txnForEnc.type !== \"pay\") {\n        // we don't support decoding this txn yet - but we can keep signing it since we have the\n        // encoded format. We trust that the caller knows what they are trying to sign.\n        var txn = Object.create(this.prototype);\n        txn.name = \"Transaction\";\n        txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n        txn.objForEncoding = txnForEnc;\n        return txn;\n      }\n\n      return _get(_getPrototypeOf(MultisigTransaction), \"from_obj_for_encoding\", this).call(this, txnForEnc);\n    }\n  }]);\n\n  return MultisigTransaction;\n}(txnBuilder.Transaction);\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\n\n\nfunction createMultisigTransaction(txnForEncoding, _ref2, _ref3) {\n  var rawSig = _ref2.rawSig,\n      myPk = _ref2.myPk;\n  var version = _ref3.version,\n      threshold = _ref3.threshold,\n      pks = _ref3.pks;\n  var keyExist = false; // construct the appendable multisigned transaction format\n\n  var subsigs = pks.map(function (pk) {\n    if (nacl.bytesEqual(pk, myPk)) {\n      keyExist = true;\n      return {\n        \"pk\": Buffer.from(pk),\n        \"s\": rawSig\n      };\n    }\n\n    return {\n      \"pk\": Buffer.from(pk)\n    };\n  });\n\n  if (keyExist === false) {\n    throw ERROR_MULTISIG_KEY_NOT_EXIST;\n  }\n\n  var msig = {\n    \"v\": version,\n    \"thr\": threshold,\n    \"subsig\": subsigs\n  };\n  var sTxn = {\n    \"msig\": msig,\n    \"txn\": txnForEncoding\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw ERROR_MULTISIG_MERGE_LESSTHANTWO;\n  }\n\n  var refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  var refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n  var refTxIDStr = refSigAlgoTx.txID().toString();\n  var from = address.encode(refSigTx.txn.snd);\n  var newSubsigs = refSigTx.msig.subsig;\n\n  for (var i = 0; i < multisigTxnBlobs.length; i++) {\n    var unisig = encoding.decode(multisigTxnBlobs[i]);\n    var unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n\n    if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n      throw ERROR_MULTISIG_MERGE_MISMATCH;\n    } // check multisig has same preimage as reference\n\n\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    }\n\n    var preimg = {\n      \"version\": unisig.msig.v,\n      \"threshold\": unisig.msig.thr,\n      \"pks\": unisig.msig.subsig.map(function (subsig) {\n        return subsig.pk;\n      })\n    };\n\n    if (from !== address.encode(address.fromMultisigPreImg(preimg))) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    } // now, we can merge\n\n\n    newSubsigs = unisig.msig.subsig.map(function (uniSubsig, index) {\n      var current = newSubsigs[index];\n\n      if (current.s) {\n        if (uniSubsig.s && Buffer.compare(uniSubsig.s, current.s) !== 0) {\n          // mismatch\n          throw ERROR_MULTISIG_MERGE_SIG_MISMATCH;\n        }\n\n        return {\n          \"pk\": current.pk,\n          \"s\": current.s\n        };\n      } else if (uniSubsig.s) {\n        return {\n          \"pk\": current.pk,\n          \"s\": uniSubsig.s\n        };\n      }\n\n      return current;\n    });\n  }\n\n  var msig = {\n    \"v\": refSigTx.msig.v,\n    \"thr\": refSigTx.msig.thr,\n    \"subsig\": newSubsigs\n  };\n  var sTxn = {\n    \"msig\": msig,\n    \"txn\": refSigTx.txn\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\nmodule.exports = {\n  MultisigTransaction: MultisigTransaction,\n  mergeMultisigTransactions: mergeMultisigTransactions,\n  createMultisigTransaction: createMultisigTransaction,\n  ERROR_MULTISIG_MERGE_LESSTHANTWO: ERROR_MULTISIG_MERGE_LESSTHANTWO,\n  ERROR_MULTISIG_MERGE_MISMATCH: ERROR_MULTISIG_MERGE_MISMATCH,\n  ERROR_MULTISIG_MERGE_WRONG_PREIMAGE: ERROR_MULTISIG_MERGE_WRONG_PREIMAGE,\n  ERROR_MULTISIG_MERGE_SIG_MISMATCH: ERROR_MULTISIG_MERGE_SIG_MISMATCH\n};","map":null,"metadata":{},"sourceType":"script"}
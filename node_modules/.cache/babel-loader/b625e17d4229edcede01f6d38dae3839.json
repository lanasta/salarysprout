{"ast":null,"code":"// Wrap a nicer JavaScript API that wraps the direct MessagePack bindings.\nvar buffer = require('buffer');\n\nvar events = require('events');\n\nvar mpBindings;\nmpBindings = require(__dirname + \"/../build/Release/msgpackBinding\");\nvar sys;\n\ntry {\n  sys = require('util');\n} catch (e) {\n  sys = require('sys');\n}\n\nvar bpack = mpBindings.pack;\nvar unpack = mpBindings.unpack;\nexports.pack = pack;\nexports.unpack = unpack;\n\nfunction pack() {\n  var args = arguments,\n      that,\n      i;\n\n  for (i = 0; i < arguments.length; i++) {\n    that = args[i];\n\n    if (that && typeof that === 'object' && typeof that.toJSON === 'function') {\n      args[i] = that.toJSON();\n    }\n  }\n\n  return bpack.apply(null, args);\n}\n\nvar Stream = function (s) {\n  var self = this;\n  events.EventEmitter.call(self); // Buffer of incomplete stream data\n\n  self.buf = null; // Send a message down the stream\n  //\n  // Allows the caller to pass additional arguments, which are passed\n  // faithfully down to the write() method of the underlying stream.\n\n  self.send = function (m) {\n    // Sigh, no arguments.slice() method\n    var args = [pack(m)];\n\n    for (i = 1; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    return s.write.apply(s, args);\n  }; // Listen for data from the underlying stream, consuming it and emitting\n  // 'msg' events as we find whole messages.\n\n\n  s.addListener('data', function (d) {\n    // Make sure that self.buf reflects the entirety of the unread stream\n    // of bytes; it needs to be a single buffer\n    if (self.buf) {\n      var b = new buffer.Buffer(self.buf.length + d.length);\n      self.buf.copy(b, 0, 0, self.buf.length);\n      d.copy(b, self.buf.length, 0, d.length);\n      self.buf = b;\n    } else {\n      self.buf = d;\n    } // Consume messages from the stream, one by one\n\n\n    while (self.buf && self.buf.length > 0) {\n      var msg = unpack(self.buf);\n\n      if (!msg) {\n        break;\n      }\n\n      self.emit('msg', msg);\n\n      if (unpack.bytes_remaining > 0) {\n        self.buf = self.buf.slice(self.buf.length - unpack.bytes_remaining, self.buf.length);\n      } else {\n        self.buf = null;\n      }\n    }\n  });\n};\n\nsys.inherits(Stream, events.EventEmitter);\nexports.Stream = Stream;","map":null,"metadata":{},"sourceType":"script"}
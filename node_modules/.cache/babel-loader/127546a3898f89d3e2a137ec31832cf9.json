{"ast":null,"code":"var nacl = require('./nacl/naclWrappers');\n\nvar address = require('./encoding/address');\n\nvar mnemonic = require('./mnemonic/mnemonic');\n\nvar encoding = require('./encoding/encoding');\n\nvar txnBuilder = require('./transaction');\n\nvar multisig = require('./multisig');\n\nvar bidBuilder = require('./bid');\n\nvar algod = require('./client/algod');\n\nvar kmd = require('./client/kmd');\n\nvar utils = require('./utils/utils');\n\nvar Algod = algod.Algod;\nvar Kmd = kmd.Kmd;\nvar SIGN_BYTES_PREFIX = Buffer.from([77, 88]); // \"MX\"\n\nvar MICROALGOS_TO_ALGOS_RATIO = 1e6; // Errors\n\nvar ERROR_MULTISIG_BAD_SENDER = new Error(\"The transaction sender address and multisig preimage do not match.\");\nvar ERROR_INVALID_MICROALGOS = new Error(\"Microalgos should be positive and less than 2^53 - 1.\");\n/**\n * generateAccount returns a new Algorand address and its corresponding secret key\n * @returns {{sk: Uint8Array, addr: string}}\n */\n\nfunction generateAccount() {\n  var keys = nacl.keyPair();\n  var encodedPk = address.encode(keys.publicKey);\n  return {\n    addr: encodedPk,\n    sk: keys.secretKey\n  };\n}\n/**\n * isValidAddress takes an Algorand address and checks if valid.\n * @param addr Algorand address\n * @returns {boolean} true if valid, false otherwise\n */\n\n\nfunction isValidAddress(addr) {\n  return address.isValidAddress(addr);\n}\n/**\n * mnemonicToSecretKey takes a mnemonic string and returns the corresponding Algorand address and its secret key.\n * @param mn 25 words Algorand mnemonic\n * @returns {{sk: Uint8Array, addr: string}}\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToSecretKey(mn) {\n  var seed = mnemonic.seedFromMnemonic(mn);\n  var keys = nacl.keyPairFromSeed(seed);\n  var encodedPk = address.encode(keys.publicKey);\n  return {\n    addr: encodedPk,\n    sk: keys.secretKey\n  };\n}\n/**\n * secretKeyToMnemonic takes an Algorand secret key and returns the corresponding mnemonic.\n * @param sk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction secretKeyToMnemonic(sk) {\n  // get the seed from the sk\n  var seed = sk.slice(0, nacl.SEED_BTYES_LENGTH);\n  return mnemonic.mnemonicFromSeed(seed);\n}\n/**\n * mnemonicToMasterDerivationKey takes a mnemonic string and returns the corresponding master derivation key.\n * @param mn 25 words Algorand mnemonic\n * @returns Uint8Array\n * @throws error if fails to decode the mnemonic\n */\n\n\nfunction mnemonicToMasterDerivationKey(mn) {\n  return mnemonic.seedFromMnemonic(mn);\n}\n/**\n * masterDerivationKeyToMnemonic takes a master derivation key and returns the corresponding mnemonic.\n * @param mdk Uint8Array\n * @returns string mnemonic\n */\n\n\nfunction masterDerivationKeyToMnemonic(mdk) {\n  return mnemonic.mnemonicFromSeed(mdk);\n}\n/**\n * signTransaction takes an object with either payment or key registration fields and \n * a secret key and returns a signed blob.\n * \n * Payment transaction fields: to, amount, fee, firstRound, lastRound, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n * \n * Key registration fields: fee, firstRound, lastRound, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n * @param txn object with either payment or key registration fields\n * @param sk Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\n\n\nfunction signTransaction(txn, sk) {\n  // Get pk from sk\n  var key = nacl.keyPairFromSecretKey(sk);\n  txn.from = address.encode(key.publicKey);\n  var algoTxn = new txnBuilder.Transaction(txn);\n  return {\n    \"txID\": algoTxn.txID().toString(),\n    \"blob\": algoTxn.signTxn(sk)\n  };\n}\n/**\n * signBid takes an object with the following fields: bidder key, bid amount, max price, bid ID, auctionKey, auction ID,\n * and a secret key and returns a signed blob to be inserted into a transaction Algorand note field.\n * @param bid Algorand Bid\n * @param sk Algorand secret key\n * @returns Uint8Array binary signed bid\n */\n\n\nfunction signBid(bid, sk) {\n  var signedBid = new bidBuilder.Bid(bid);\n  return signedBid.signBid(sk);\n}\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes \n * with the private key, and returns the signature.\n * @param bytes Uint8array\n * @param sk Algorand secret key\n * @returns binary signature\n */\n\n\nfunction signBytes(bytes, sk) {\n  var toBeSigned = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  var sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\n * verifyBytes takes arbitraray bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes Uint8Array\n * @param signature binary signature\n * @param addr string address\n * @returns bool\n */\n\n\nfunction verifyBytes(bytes, signature, addr) {\n  toBeVerified = Buffer.from(utils.concatArrays(SIGN_BYTES_PREFIX, bytes));\n  var pk = address.decode(addr).publicKey;\n  return nacl.verify(toBeVerified, signature, pk);\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendMultisigTransaction.\n * @param txn object with either payment or key registration fields\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n */\n\n\nfunction signMultisigTransaction(txn, _ref, sk) {\n  var version = _ref.version,\n      threshold = _ref.threshold,\n      addrs = _ref.addrs;\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  var expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version: version,\n    threshold: threshold,\n    addrs: addrs\n  });\n\n  if (txn.hasOwnProperty('from')) {\n    if (txn.from !== expectedFromRaw) {\n      throw ERROR_MULTISIG_BAD_SENDER;\n    }\n  } else {\n    txn.from = expectedFromRaw;\n  }\n\n  var algoTxn = new multisig.MultisigTransaction(txn);\n  var pks = addrs.map(function (addr) {\n    return address.decode(addr).publicKey;\n  });\n  return {\n    \"txID\": algoTxn.txID().toString(),\n    \"blob\": algoTxn.partialSignTxn({\n      version: version,\n      threshold: threshold,\n      pks: pks\n    }, sk)\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob an encoded multisig txn. Supports non-payment txn types.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\n\n\nfunction appendSignMultisigTransaction(multisigTxnBlob, _ref2, sk) {\n  var version = _ref2.version,\n      threshold = _ref2.threshold,\n      addrs = _ref2.addrs;\n  var pks = addrs.map(function (addr) {\n    return address.decode(addr).publicKey;\n  }); // obtain underlying txn, sign it, and merge it\n\n  var multisigTxObj = encoding.decode(multisigTxnBlob);\n  var msigTxn = multisig.MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  var partialSignedBlob = msigTxn.partialSignTxn({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  }, sk);\n  return {\n    \"txID\": msigTxn.txID().toString(),\n    \"blob\": mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns blob representing encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  return multisig.mergeMultisigTransactions(multisigTxnBlobs);\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version mutlisig version\n * @param threshold multisig threshold\n * @param addrs list of Algorand addresses\n */\n\n\nfunction multisigAddress(_ref3) {\n  var version = _ref3.version,\n      threshold = _ref3.threshold,\n      addrs = _ref3.addrs;\n  return address.fromMultisigPreImgAddrs({\n    version: version,\n    threshold: threshold,\n    addrs: addrs\n  });\n}\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o js obj\n * @returns Uint8Array binary representation\n */\n\n\nfunction encodeObj(o) {\n  return new Uint8Array(encoding.encode(o));\n}\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o Uint8Array to decode\n * @returns object\n */\n\n\nfunction decodeObj(o) {\n  return encoding.decode(o);\n}\n/**\n * microalgosToAlgos converts microalgos to algos\n * @param microalgos number\n * @returns number\n */\n\n\nfunction microalgosToAlgos(microalgos) {\n  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {\n    throw ERROR_INVALID_MICROALGOS;\n  }\n\n  return microalgos / MICROALGOS_TO_ALGOS_RATIO;\n}\n/**\n * algosToMicroalgos converts algos to microalgos\n * @param algos number\n * @returns number\n */\n\n\nfunction algosToMicroalgos(algos) {\n  var microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;\n  return Math.round(microalgos);\n}\n\nmodule.exports = {\n  isValidAddress: isValidAddress,\n  generateAccount: generateAccount,\n  secretKeyToMnemonic: secretKeyToMnemonic,\n  mnemonicToSecretKey: mnemonicToSecretKey,\n  signTransaction: signTransaction,\n  signBid: signBid,\n  signBytes: signBytes,\n  verifyBytes: verifyBytes,\n  encodeObj: encodeObj,\n  decodeObj: decodeObj,\n  Algod: Algod,\n  Kmd: Kmd,\n  mnemonicToMasterDerivationKey: mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic: masterDerivationKeyToMnemonic,\n  appendSignMultisigTransaction: appendSignMultisigTransaction,\n  mergeMultisigTransactions: mergeMultisigTransactions,\n  signMultisigTransaction: signMultisigTransaction,\n  multisigAddress: multisigAddress,\n  ERROR_MULTISIG_BAD_SENDER: ERROR_MULTISIG_BAD_SENDER,\n  ERROR_INVALID_MICROALGOS: ERROR_INVALID_MICROALGOS,\n  microalgosToAlgos: microalgosToAlgos,\n  algosToMicroalgos: algosToMicroalgos\n};","map":null,"metadata":{},"sourceType":"script"}
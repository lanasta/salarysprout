{"ast":null,"code":"var base32 = require('hi-base32');\n\nvar nacl = require('../nacl/naclWrappers');\n\nvar utils = require('../utils/utils');\n\nvar ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nvar ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nvar ALGORAND_ADDRESS_LENGTH = 58; // Convert \"MultisigAddr\" UTF-8 to byte array\n\nvar MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nvar MALFORMED_ADDRESS_ERROR = new Error(\"address seems to be malformed\");\nvar INVALID_MSIG_VERSION = new Error(\"invalid multisig version\");\nvar INVALID_MSIG_THRESHOLD = new Error(\"bad multisig threshold\");\nvar INVALID_MSIG_PK = new Error(\"bad multisig public key - wrong length\");\nvar UNEXPECTED_PK_LEN = new Error(\"nacl public key length is not 32 bytes\");\n/**\n * isValidAddress takes an Algorand address and checks if valid.\n * @param address Algorand address\n * @returns {boolean}n true if valid, false otherwise\n */\n\nfunction isValidAddress(address) {\n  if (typeof address !== \"string\") return false;\n  if (address.length !== ALGORAND_ADDRESS_LENGTH) return false; // Try to decode\n\n  var decoded;\n\n  try {\n    decoded = decode(address);\n  } catch (e) {\n    return false;\n  } // Compute checksum\n\n\n  var checksum = nacl.genericHash(decoded.publicKey).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH); // Check if the checksum and the address are equal\n\n  return utils.arrayEqual(checksum, decoded.checksum);\n}\n\nfunction decode(address) {\n  if (!(typeof address === \"string\" || address instanceof String)) throw MALFORMED_ADDRESS_ERROR; //try to decode\n\n  var decoded = base32.decode.asBytes(address); // Sanity check\n\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw MALFORMED_ADDRESS_ERROR;\n  var pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  var cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n  return {\n    \"publicKey\": pk,\n    \"checksum\": cs\n  };\n}\n\nfunction encode(address) {\n  //compute checksum\n  var checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  var addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param pks array of typed array public keys\n */\n\n\nfunction fromMultisigPreImg(_ref) {\n  var version = _ref.version,\n      threshold = _ref.threshold,\n      pks = _ref.pks;\n\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw INVALID_MSIG_VERSION;\n  }\n\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw INVALID_MSIG_THRESHOLD;\n  }\n\n  var pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw UNEXPECTED_PK_LEN;\n  }\n\n  var merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n\n  for (var i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw INVALID_MSIG_PK;\n    }\n\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n\n  return nacl.genericHash(merged);\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version multisig version\n * @param threshold multisig threshold\n * @param addrs array of encoded addresses\n */\n\n\nfunction fromMultisigPreImgAddrs(_ref2) {\n  var version = _ref2.version,\n      threshold = _ref2.threshold,\n      addrs = _ref2.addrs;\n  var pks = addrs.map(function (addr) {\n    return decode(addr).publicKey;\n  });\n  return encode(fromMultisigPreImg({\n    version: version,\n    threshold: threshold,\n    pks: pks\n  }));\n}\n\nmodule.exports = {\n  isValidAddress: isValidAddress,\n  decode: decode,\n  encode: encode,\n  fromMultisigPreImg: fromMultisigPreImg,\n  fromMultisigPreImgAddrs: fromMultisigPreImgAddrs,\n  MALFORMED_ADDRESS_ERROR: MALFORMED_ADDRESS_ERROR,\n  INVALID_MSIG_VERSION: INVALID_MSIG_VERSION,\n  INVALID_MSIG_THRESHOLD: INVALID_MSIG_THRESHOLD,\n  INVALID_MSIG_PK: INVALID_MSIG_PK,\n  UNEXPECTED_PK_LEN: UNEXPECTED_PK_LEN\n};","map":null,"metadata":{},"sourceType":"script"}
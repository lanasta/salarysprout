{"ast":null,"code":"var _classCallCheck = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar address = require(\"./encoding/address\");\n\nvar encoding = require(\"./encoding/encoding\");\n\nvar nacl = require(\"./nacl/naclWrappers\");\n\nvar utils = require(\"./utils/utils\");\n\nvar base32 = require('hi-base32');\n\nvar ALGORAND_TRANSACTION_LENGTH = 52;\nvar ALGORAND_MIN_TX_FEE = 1000; // version v5\n\n/**\n * Transaction enables construction of Algorand transactions\n * */\n\nvar Transaction =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Transaction(_ref) {\n    var from = _ref.from,\n        to = _ref.to,\n        fee = _ref.fee,\n        amount = _ref.amount,\n        firstRound = _ref.firstRound,\n        lastRound = _ref.lastRound,\n        note = _ref.note,\n        genesisID = _ref.genesisID,\n        genesisHash = _ref.genesisHash,\n        closeRemainderTo = _ref.closeRemainderTo,\n        voteKey = _ref.voteKey,\n        selectionKey = _ref.selectionKey,\n        voteFirst = _ref.voteFirst,\n        voteLast = _ref.voteLast,\n        voteKeyDilution = _ref.voteKeyDilution,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? \"pay\" : _ref$type,\n        _ref$flatFee = _ref.flatFee,\n        flatFee = _ref$flatFee === void 0 ? false : _ref$flatFee;\n\n    _classCallCheck(this, Transaction);\n\n    this.name = \"Transaction\";\n    this.tag = Buffer.from([84, 88]); // \"TX\"\n\n    from = address.decode(from);\n    if (to !== undefined) to = address.decode(to);\n    if (closeRemainderTo !== undefined) closeRemainderTo = address.decode(closeRemainderTo);\n    if (genesisHash === undefined) throw Error(\"genesis hash must be specified and in a base64 string.\");\n    genesisHash = Buffer.from(genesisHash, 'base64');\n    if (amount !== undefined && (!Number.isSafeInteger(amount) || amount < 0)) throw Error(\"Amount must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(fee) || fee < 0) throw Error(\"fee must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(firstRound) || firstRound < 0) throw Error(\"firstRound must be a positive number\");\n    if (!Number.isSafeInteger(lastRound) || lastRound < 0) throw Error(\"lastRound must be a positive number\");\n\n    if (note !== undefined) {\n      if (note.constructor !== Uint8Array) throw Error(\"note must be a Uint8Array.\");\n    } else {\n      note = new Uint8Array(0);\n    }\n\n    if (voteKey !== undefined) {\n      voteKey = Buffer.from(voteKey, \"base64\");\n    }\n\n    if (selectionKey !== undefined) {\n      selectionKey = Buffer.from(selectionKey, \"base64\");\n    }\n\n    Object.assign(this, {\n      from: from,\n      to: to,\n      fee: fee,\n      amount: amount,\n      firstRound: firstRound,\n      lastRound: lastRound,\n      note: note,\n      genesisHash: genesisHash,\n      genesisID: genesisID,\n      closeRemainderTo: closeRemainderTo,\n      voteKey: voteKey,\n      selectionKey: selectionKey,\n      voteFirst: voteFirst,\n      voteLast: voteLast,\n      voteKeyDilution: voteKeyDilution,\n      type: type\n    }); // Modify Fee\n\n    if (!flatFee) {\n      this.fee *= this.estimateSize();\n    } // If suggested fee too small and will be rejected, set to min tx fee\n\n\n    if (this.fee < ALGORAND_MIN_TX_FEE) {\n      this.fee = ALGORAND_MIN_TX_FEE;\n    }\n  }\n\n  _createClass(Transaction, [{\n    key: \"get_obj_for_encoding\",\n    value: function get_obj_for_encoding() {\n      if (this.type == \"pay\") {\n        var txn = {\n          \"amt\": this.amount,\n          \"fee\": this.fee,\n          \"fv\": this.firstRound,\n          \"lv\": this.lastRound,\n          \"note\": Buffer.from(this.note),\n          \"rcv\": Buffer.from(this.to.publicKey),\n          \"snd\": Buffer.from(this.from.publicKey),\n          \"type\": \"pay\",\n          \"gen\": this.genesisID,\n          \"gh\": this.genesisHash\n        }; // parse close address\n\n        if (this.closeRemainderTo !== undefined) txn.close = Buffer.from(this.closeRemainderTo.publicKey); // allowed zero values\n\n        if (!txn.note.length) delete txn.note;\n        if (!txn.amt) delete txn.amt;\n        if (!txn.fee) delete txn.fee;\n        if (!txn.gen) delete txn.gen;\n        return txn;\n      } else if (this.type == \"keyreg\") {\n        var _txn = {\n          \"fee\": this.fee,\n          \"fv\": this.firstRound,\n          \"lv\": this.lastRound,\n          \"note\": Buffer.from(this.note),\n          \"snd\": Buffer.from(this.from.publicKey),\n          \"type\": this.type,\n          \"gen\": this.genesisID,\n          \"gh\": this.genesisHash,\n          \"votekey\": this.voteKey,\n          \"selkey\": this.selectionKey,\n          \"votefst\": this.voteFirst,\n          \"votelst\": this.voteLast,\n          \"votekd\": this.voteKeyDilution\n        }; // allowed zero values\n\n        if (!_txn.note.length) delete _txn.note;\n        if (!_txn.fee) delete _txn.fee;\n        if (!_txn.gen) delete _txn.gen;\n        return _txn;\n      }\n    }\n  }, {\n    key: \"estimateSize\",\n    value: function estimateSize() {\n      // Generate random key\n      var key = nacl.keyPair();\n      return this.signTxn(key.secretKey).length;\n    }\n  }, {\n    key: \"bytesToSign\",\n    value: function bytesToSign() {\n      var encodedMsg = this.toByte();\n      return Buffer.from(utils.concatArrays(this.tag, encodedMsg));\n    }\n  }, {\n    key: \"toByte\",\n    value: function toByte() {\n      return encoding.encode(this.get_obj_for_encoding());\n    } // returns the raw signature\n\n  }, {\n    key: \"rawSignTxn\",\n    value: function rawSignTxn(sk) {\n      var toBeSigned = this.bytesToSign();\n      var sig = nacl.sign(toBeSigned, sk);\n      return Buffer.from(sig);\n    }\n  }, {\n    key: \"signTxn\",\n    value: function signTxn(sk) {\n      // construct signed message\n      var sTxn = {\n        \"sig\": this.rawSignTxn(sk),\n        \"txn\": this.get_obj_for_encoding()\n      };\n      return new Uint8Array(encoding.encode(sTxn));\n    }\n  }, {\n    key: \"txID\",\n    value: function txID() {\n      var en_msg = encoding.encode(this.get_obj_for_encoding());\n      var gh = Buffer.from(utils.concatArrays(this.tag, en_msg));\n      return base32.encode(nacl.genericHash(gh)).slice(0, ALGORAND_TRANSACTION_LENGTH);\n    }\n  }], [{\n    key: \"from_obj_for_encoding\",\n    value: function from_obj_for_encoding(txnForEnc) {\n      var txn = Object.create(this.prototype);\n      txn.name = \"Transaction\";\n      txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n      txn.genesisID = txnForEnc.gen;\n      txn.genesisHash = Buffer.from(txnForEnc.gh);\n      txn.type = txnForEnc.type;\n      txn.fee = txnForEnc.fee;\n      txn.firstRound = txnForEnc.fv;\n      txn.lastRound = txnForEnc.lv;\n      txn.note = new Uint8Array(txnForEnc.note);\n      txn.from = address.decode(address.encode(new Uint8Array(txnForEnc.snd)));\n\n      if (txnForEnc.type === \"pay\") {\n        txn.amount = txnForEnc.amt;\n        txn.to = address.decode(address.encode(new Uint8Array(txnForEnc.rcv)));\n        if (txnForEnc.close !== undefined) txn.closeRemainderTo = address.decode(address.encode(txnForEnc.close));\n      } else if (txnForEnc.type === \"keyreg\") {\n        txn.voteKey = Buffer.from(txnForEnc.votekey);\n        txn.selectionKey = Buffer.from(txnForEnc.selkey);\n        txn.voteKeyDilution = txnForEnc.votekd;\n        txn.voteFirst = txnForEnc.votefst;\n        txn.voteLast = txnForEnc.votelst;\n      }\n\n      return txn;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nmodule.exports = {\n  Transaction: Transaction\n};","map":null,"metadata":{},"sourceType":"script"}
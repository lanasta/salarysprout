{"ast":null,"code":"const client = require('./client'); // token can either be the X-Algo-API-Token string value or is a JS Object to allow setting multiple headers in the request\n// ex. \n// const token = {\n//    'X-API-Key': 'SOME VALUE',\n//   'X-Algo-API-Token': 'ANOTHER VALUE'\n// };\n// const algodclient = new algosdk.Algod(token, baseServer, port);\n\n\nfunction Algod(token = '', baseServer = \"http://r2.algorand.network\", port = 4180) {\n  // workaround to allow backwards compatibility for multiple headers\n  let requestHeaders = token;\n\n  if (typeof requestHeaders == 'string') {\n    requestHeaders = {\n      'X-Algo-API-Token': requestHeaders\n    };\n  } // Get client\n\n\n  let c = new client.HTTPClient(requestHeaders, baseServer, port);\n  /**\n   * Takes an object and convert its note field to Buffer, if exist.\n   * @param o\n   * @returns {*}\n   */\n\n  function noteb64ToNote(o) {\n    if (o.noteb64 !== undefined) {\n      o.note = Buffer.from(o.noteb64, \"base64\");\n    }\n\n    return o;\n  }\n  /**\n   * status retrieves the StatusResponse from the running node\n   * @returns {Promise<*>}\n   */\n\n\n  this.status = async function () {\n    let res = await c.get(\"/v1/status\");\n    return res.body;\n  };\n  /**\n   * healthCheck returns an empty object iff the node is running\n   * @returns {Promise<*>}\n   */\n\n\n  this.healthCheck = async function () {\n    let res = await c.get(\"/health\");\n    return res.body;\n  };\n  /**\n   * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n   * This call blocks\n   * @param roundNumber\n   * @returns {Promise<*>}\n   */\n\n\n  this.statusAfterBlock = async function (roundNumber) {\n    if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n    let res = await c.get(\"/v1/status/wait-for-block-after/\" + roundNumber);\n    return res.body;\n  };\n  /**\n   * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n   * If maxTxns = 0, fetches as many transactions as possible.\n   * @param maxTxns number\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactions = async function (maxTxns) {\n    if (!Number.isInteger(maxTxns)) throw Error(\"maxTxns should be an integer\");\n    let res = await c.get(\"/v1/transactions/pending\", {\n      'max': maxTxns\n    });\n\n    if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {\n      for (let i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n        res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * versions retrieves the VersionResponse from the running node\n   * @returns {Promise<*>}\n   */\n\n\n  this.versions = async function () {\n    let res = await c.get(\"/versions\");\n    return res.body;\n  };\n  /**\n   * LedgerSupply gets the supply details for the specified node's Ledger\n   * @returns {Promise<*>}\n   */\n\n\n  this.ledgerSupply = async function () {\n    let res = await c.get(\"/v1/ledger/supply\");\n    return res.body;\n  };\n  /**\n   * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n   * @param addr string\n   * @param first number, optional\n   * @param last number, optional\n   * @param maxTxns number, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddress = async function (addr, first = null, last = null, maxTxns = null) {\n    if (first !== null && !Number.isInteger(first)) {\n      throw Error(\"first round should be an integer\");\n    }\n\n    if (last !== null && !Number.isInteger(last)) {\n      throw Error(\"last round should be an integer\");\n    }\n\n    let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", {\n      'firstRound': first,\n      'lastRound': last,\n      'max': maxTxns\n    });\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range. \n   * The date is a string in the YYYY-MM-DD format.\n   * @param addr string\n   * @param fromDate string\n   * @param toDate string\n   * @param maxTxns number, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddressAndDate = async function (addr, fromDate, toDate, maxTxns = null) {\n    let res = await c.get(\"/v1/account/\" + addr + \"/transactions\", {\n      'fromDate': fromDate,\n      'toDate': toDate,\n      'max': maxTxns\n    });\n\n    if (res.statusCode === 200 && res.body.transactions !== undefined) {\n      for (let i = 0; i < res.body.transactions.length; i++) {\n        res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionById returns the a transaction information of a specific txid [txId]\n   * Note - This method is allowed only when Indexer is enabled.\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionById = async function (txid) {\n    let res = await c.get(\"/v1/transaction/\" + txid);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * transactionInformation returns the transaction information of a specific txid and an address\n   * @param addr\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionInformation = async function (addr, txid) {\n    let res = await c.get(\"/v1/account/\" + addr + \"/transaction/\" + txid);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactionInformation = async function (txid) {\n    let res = await c.get(\"/v1/transactions/pending/\" + txid);\n\n    if (res.statusCode === 200) {\n      res.body = noteb64ToNote(res.body);\n    }\n\n    return res.body;\n  };\n  /**\n   * accountInformation returns the passed account's information\n   * @param addr string\n   * @returns {Promise<*>}\n   */\n\n\n  this.accountInformation = async function (addr) {\n    let res = await c.get(\"/v1/account/\" + addr);\n    return res.body;\n  };\n  /**\n   * suggestedFee gets the recommended transaction fee from the node\n   * @returns {Promise<*>}\n   */\n\n\n  this.suggestedFee = async function () {\n    let res = await c.get(\"/v1/transactions/fee\");\n    return res.body;\n  };\n  /**\n   * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n   * @param txn Uin8Array\n   * @returns {Promise<*>}\n   */\n\n\n  this.sendRawTransaction = async function (txn) {\n    let res = await c.post(\"/v1/transactions\", Buffer.from(txn));\n    return res.body;\n  };\n  /**\n   * getTransactionParams returns to common needed parameters for a new transaction\n   * @returns {Promise<*>}\n   */\n\n\n  this.getTransactionParams = async function () {\n    let res = await c.get(\"/v1/transactions/params\");\n    return res.body;\n  };\n  /**\n   * block gets the block info for the given round This call blocks\n   * @param roundNumber\n   * @returns {Promise<*>}\n   */\n\n\n  this.block = async function (roundNumber) {\n    if (!Number.isInteger(roundNumber)) throw Error(\"roundNumber should be an integer\");\n    let res = await c.get(\"/v1/block/\" + roundNumber);\n\n    if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n      for (let i = 0; i < res.body.txns.transactions.length; i++) {\n        res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);\n      }\n    }\n\n    return res.body;\n  };\n}\n\nmodule.exports = {\n  Algod\n};","map":null,"metadata":{},"sourceType":"script"}
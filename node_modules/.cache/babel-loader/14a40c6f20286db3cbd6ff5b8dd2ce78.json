{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/aslalamentik/Desktop/salarysprout/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar client = require('./client'); // token can either be the X-Algo-API-Token string value or is a JS Object to allow setting multiple headers in the request\n// ex. \n// const token = {\n//    'X-API-Key': 'SOME VALUE',\n//   'X-Algo-API-Token': 'ANOTHER VALUE'\n// };\n// const algodclient = new algosdk.Algod(token, baseServer, port);\n\n\nfunction Algod() {\n  var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var baseServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"http://r2.algorand.network\";\n  var port = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4180;\n  // workaround to allow backwards compatibility for multiple headers\n  var requestHeaders = token;\n\n  if (typeof requestHeaders == 'string') {\n    requestHeaders = {\n      'X-Algo-API-Token': requestHeaders\n    };\n  } // Get client\n\n\n  var c = new client.HTTPClient(requestHeaders, baseServer, port);\n  /**\n   * Takes an object and convert its note field to Buffer, if exist.\n   * @param o\n   * @returns {*}\n   */\n\n  function noteb64ToNote(o) {\n    if (o.noteb64 !== undefined) {\n      o.note = Buffer.from(o.noteb64, \"base64\");\n    }\n\n    return o;\n  }\n  /**\n   * status retrieves the StatusResponse from the running node\n   * @returns {Promise<*>}\n   */\n\n\n  this.status =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return c.get(\"/v1/status\");\n\n          case 2:\n            res = _context.sent;\n            return _context.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  /**\n   * healthCheck returns an empty object iff the node is running\n   * @returns {Promise<*>}\n   */\n\n  this.healthCheck =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return c.get(\"/health\");\n\n          case 2:\n            res = _context2.sent;\n            return _context2.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  /**\n   * statusAfterBlock waits for round roundNumber to occur then returns the StatusResponse for this round.\n   * This call blocks\n   * @param roundNumber\n   * @returns {Promise<*>}\n   */\n\n  this.statusAfterBlock =\n  /*#__PURE__*/\n  function () {\n    var _ref3 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(roundNumber) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (Number.isInteger(roundNumber)) {\n                _context3.next = 2;\n                break;\n              }\n\n              throw Error(\"roundNumber should be an integer\");\n\n            case 2:\n              _context3.next = 4;\n              return c.get(\"/v1/status/wait-for-block-after/\" + roundNumber);\n\n            case 4:\n              res = _context3.sent;\n              return _context3.abrupt(\"return\", res.body);\n\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * pendingTransactions asks algod for a snapshot of current pending txns on the node, bounded by maxTxns.\n   * If maxTxns = 0, fetches as many transactions as possible.\n   * @param maxTxns number\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactions =\n  /*#__PURE__*/\n  function () {\n    var _ref4 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4(maxTxns) {\n      var res, i;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (Number.isInteger(maxTxns)) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw Error(\"maxTxns should be an integer\");\n\n            case 2:\n              _context4.next = 4;\n              return c.get(\"/v1/transactions/pending\", {\n                'max': maxTxns\n              });\n\n            case 4:\n              res = _context4.sent;\n\n              if (res.statusCode === 200 && res.body.truncatedTxns.transactions !== undefined) {\n                for (i = 0; i < res.body.truncatedTxns.transactions.length; i++) {\n                  res.body.truncatedTxns.transactions[i] = noteb64ToNote(res.body.truncatedTxns.transactions[i]);\n                }\n              }\n\n              return _context4.abrupt(\"return\", res.body);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  /**\n   * versions retrieves the VersionResponse from the running node\n   * @returns {Promise<*>}\n   */\n\n\n  this.versions =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return c.get(\"/versions\");\n\n          case 2:\n            res = _context5.sent;\n            return _context5.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  /**\n   * LedgerSupply gets the supply details for the specified node's Ledger\n   * @returns {Promise<*>}\n   */\n\n  this.ledgerSupply =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee6() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            _context6.next = 2;\n            return c.get(\"/v1/ledger/supply\");\n\n          case 2:\n            res = _context6.sent;\n            return _context6.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  /**\n   * transactionsByAddress returns all transactions for a PK [addr] in the [first, last] rounds range.\n   * @param addr string\n   * @param first number, optional\n   * @param last number, optional\n   * @param maxTxns number, optional\n   * @returns {Promise<*>}\n   */\n\n  this.transactionByAddress =\n  /*#__PURE__*/\n  function () {\n    var _ref7 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7(addr) {\n      var first,\n          last,\n          maxTxns,\n          res,\n          i,\n          _args7 = arguments;\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              first = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : null;\n              last = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : null;\n              maxTxns = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : null;\n\n              if (!(first !== null && !Number.isInteger(first))) {\n                _context7.next = 5;\n                break;\n              }\n\n              throw Error(\"first round should be an integer\");\n\n            case 5:\n              if (!(last !== null && !Number.isInteger(last))) {\n                _context7.next = 7;\n                break;\n              }\n\n              throw Error(\"last round should be an integer\");\n\n            case 7:\n              _context7.next = 9;\n              return c.get(\"/v1/account/\" + addr + \"/transactions\", {\n                'firstRound': first,\n                'lastRound': last,\n                'max': maxTxns\n              });\n\n            case 9:\n              res = _context7.sent;\n\n              if (res.statusCode === 200 && res.body.transactions !== undefined) {\n                for (i = 0; i < res.body.transactions.length; i++) {\n                  res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n                }\n              }\n\n              return _context7.abrupt(\"return\", res.body);\n\n            case 12:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7);\n    }));\n\n    return function (_x3) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  /**\n   * transactionsByAddressAndDate returns all transactions for a PK [addr] in the [fromDate, toDate] date range. \n   * The date is a string in the YYYY-MM-DD format.\n   * @param addr string\n   * @param fromDate string\n   * @param toDate string\n   * @param maxTxns number, optional\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionByAddressAndDate =\n  /*#__PURE__*/\n  function () {\n    var _ref8 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee8(addr, fromDate, toDate) {\n      var maxTxns,\n          res,\n          i,\n          _args8 = arguments;\n      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              maxTxns = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : null;\n              _context8.next = 3;\n              return c.get(\"/v1/account/\" + addr + \"/transactions\", {\n                'fromDate': fromDate,\n                'toDate': toDate,\n                'max': maxTxns\n              });\n\n            case 3:\n              res = _context8.sent;\n\n              if (res.statusCode === 200 && res.body.transactions !== undefined) {\n                for (i = 0; i < res.body.transactions.length; i++) {\n                  res.body.transactions[i] = noteb64ToNote(res.body.transactions[i]);\n                }\n              }\n\n              return _context8.abrupt(\"return\", res.body);\n\n            case 6:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n\n    return function (_x4, _x5, _x6) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  /**\n   * transactionById returns the a transaction information of a specific txid [txId]\n   * Note - This method is allowed only when Indexer is enabled.\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionById =\n  /*#__PURE__*/\n  function () {\n    var _ref9 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee9(txid) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return c.get(\"/v1/transaction/\" + txid);\n\n            case 2:\n              res = _context9.sent;\n\n              if (res.statusCode === 200) {\n                res.body = noteb64ToNote(res.body);\n              }\n\n              return _context9.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n\n    return function (_x7) {\n      return _ref9.apply(this, arguments);\n    };\n  }();\n  /**\n   * transactionInformation returns the transaction information of a specific txid and an address\n   * @param addr\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.transactionInformation =\n  /*#__PURE__*/\n  function () {\n    var _ref10 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee10(addr, txid) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return c.get(\"/v1/account/\" + addr + \"/transaction/\" + txid);\n\n            case 2:\n              res = _context10.sent;\n\n              if (res.statusCode === 200) {\n                res.body = noteb64ToNote(res.body);\n              }\n\n              return _context10.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, _callee10);\n    }));\n\n    return function (_x8, _x9) {\n      return _ref10.apply(this, arguments);\n    };\n  }();\n  /**\n   * pendingTransactionInformation returns the transaction information for a specific txid of a pending transaction\n   * @param txid\n   * @returns {Promise<*>}\n   */\n\n\n  this.pendingTransactionInformation =\n  /*#__PURE__*/\n  function () {\n    var _ref11 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee11(txid) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return c.get(\"/v1/transactions/pending/\" + txid);\n\n            case 2:\n              res = _context11.sent;\n\n              if (res.statusCode === 200) {\n                res.body = noteb64ToNote(res.body);\n              }\n\n              return _context11.abrupt(\"return\", res.body);\n\n            case 5:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, _callee11);\n    }));\n\n    return function (_x10) {\n      return _ref11.apply(this, arguments);\n    };\n  }();\n  /**\n   * accountInformation returns the passed account's information\n   * @param addr string\n   * @returns {Promise<*>}\n   */\n\n\n  this.accountInformation =\n  /*#__PURE__*/\n  function () {\n    var _ref12 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee12(addr) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return c.get(\"/v1/account/\" + addr);\n\n            case 2:\n              res = _context12.sent;\n              return _context12.abrupt(\"return\", res.body);\n\n            case 4:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, _callee12);\n    }));\n\n    return function (_x11) {\n      return _ref12.apply(this, arguments);\n    };\n  }();\n  /**\n   * suggestedFee gets the recommended transaction fee from the node\n   * @returns {Promise<*>}\n   */\n\n\n  this.suggestedFee =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee13() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            _context13.next = 2;\n            return c.get(\"/v1/transactions/fee\");\n\n          case 2:\n            res = _context13.sent;\n            return _context13.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  /**\n   * sendRawTransaction gets an encoded SignedTxn and broadcasts it to the network\n   * @param txn Uin8Array\n   * @returns {Promise<*>}\n   */\n\n  this.sendRawTransaction =\n  /*#__PURE__*/\n  function () {\n    var _ref14 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee14(txn) {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return c.post(\"/v1/transactions\", Buffer.from(txn));\n\n            case 2:\n              res = _context14.sent;\n              return _context14.abrupt(\"return\", res.body);\n\n            case 4:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, _callee14);\n    }));\n\n    return function (_x12) {\n      return _ref14.apply(this, arguments);\n    };\n  }();\n  /**\n   * getTransactionParams returns to common needed parameters for a new transaction\n   * @returns {Promise<*>}\n   */\n\n\n  this.getTransactionParams =\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee15() {\n    var res;\n    return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            _context15.next = 2;\n            return c.get(\"/v1/transactions/params\");\n\n          case 2:\n            res = _context15.sent;\n            return _context15.abrupt(\"return\", res.body);\n\n          case 4:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  /**\n   * block gets the block info for the given round This call blocks\n   * @param roundNumber\n   * @returns {Promise<*>}\n   */\n\n  this.block =\n  /*#__PURE__*/\n  function () {\n    var _ref16 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee16(roundNumber) {\n      var res, i;\n      return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              if (Number.isInteger(roundNumber)) {\n                _context16.next = 2;\n                break;\n              }\n\n              throw Error(\"roundNumber should be an integer\");\n\n            case 2:\n              _context16.next = 4;\n              return c.get(\"/v1/block/\" + roundNumber);\n\n            case 4:\n              res = _context16.sent;\n\n              if (res.statusCode === 200 && res.body.txns.transactions !== undefined) {\n                for (i = 0; i < res.body.txns.transactions.length; i++) {\n                  res.body.txns.transactions[i] = noteb64ToNote(res.body.txns.transactions[i]);\n                }\n              }\n\n              return _context16.abrupt(\"return\", res.body);\n\n            case 7:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, _callee16);\n    }));\n\n    return function (_x13) {\n      return _ref16.apply(this, arguments);\n    };\n  }();\n}\n\nmodule.exports = {\n  Algod: Algod\n};","map":null,"metadata":{},"sourceType":"script"}
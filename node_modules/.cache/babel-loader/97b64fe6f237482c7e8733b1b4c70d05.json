{"ast":null,"code":"const nacl = require('./nacl/naclWrappers');\n\nconst address = require('./encoding/address');\n\nconst encoding = require('./encoding/encoding');\n\nconst txnBuilder = require('./transaction');\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\n\nconst ERROR_MULTISIG_MERGE_LESSTHANTWO = new Error(\"Not enough multisig transactions to merge. Need at least two\");\nconst ERROR_MULTISIG_MERGE_MISMATCH = new Error(\"Cannot merge txs. txIDs differ\");\nconst ERROR_MULTISIG_MERGE_WRONG_PREIMAGE = new Error(\"Cannot merge txs. Multisig preimages differ\");\nconst ERROR_MULTISIG_MERGE_SIG_MISMATCH = new Error(\"Cannot merge txs. subsigs are mismatched.\");\nconst ERROR_MULTISIG_BAD_FROM_FIELD = new Error(\"The transaction from field and multisig preimage do not match.\");\nconst ERROR_MULTISIG_KEY_NOT_EXIST = new Error(\"Key does not exist\");\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\n\nclass MultisigTransaction extends txnBuilder.Transaction {\n  get_obj_for_encoding() {\n    if (this.hasOwnProperty(\"objForEncoding\")) {\n      // if set, use the value for encoding. This allows us to sign existing non-payment type transactions.\n      return this.objForEncoding;\n    }\n\n    return super.get_obj_for_encoding();\n  }\n\n  static from_obj_for_encoding(txnForEnc) {\n    if (txnForEnc.type !== \"pay\") {\n      // we don't support decoding this txn yet - but we can keep signing it since we have the\n      // encoded format. We trust that the caller knows what they are trying to sign.\n      let txn = Object.create(this.prototype);\n      txn.name = \"Transaction\";\n      txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n      txn.objForEncoding = txnForEnc;\n      return txn;\n    }\n\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version multisig version\n   * @param threshold multisig threshold\n   * @param pks multisig public key list, order is important.\n   * @param sk an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n\n\n  partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk) {\n    // verify one more time that the from field is correct\n    if (!this.hasOwnProperty(\"objForEncoding\")) {\n      let expectedFromRaw = address.fromMultisigPreImg({\n        version,\n        threshold,\n        pks\n      });\n\n      if (address.encode(this.from.publicKey) !== address.encode(expectedFromRaw)) {\n        throw ERROR_MULTISIG_BAD_FROM_FIELD;\n      }\n    } // get signature verifier\n\n\n    let myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransaction(this.get_obj_for_encoding(), {\n      \"rawSig\": this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n\n}\n/**\n * createMultisigTransaction creates a multisig transaction blob.\n * @param txnForEncoding the actual transaction to sign.\n * @param rawSig a Buffer raw signature of that transaction\n * @param myPk a public key that corresponds with rawSig\n * @param version multisig version\n * @param threshold mutlisig threshold\n * @param pks ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\n\n\nfunction createMultisigTransaction(txnForEncoding, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  let keyExist = false; // construct the appendable multisigned transaction format\n\n  let subsigs = pks.map(pk => {\n    if (nacl.bytesEqual(pk, myPk)) {\n      keyExist = true;\n      return {\n        \"pk\": Buffer.from(pk),\n        \"s\": rawSig\n      };\n    }\n\n    return {\n      \"pk\": Buffer.from(pk)\n    };\n  });\n\n  if (keyExist === false) {\n    throw ERROR_MULTISIG_KEY_NOT_EXIST;\n  }\n\n  let msig = {\n    \"v\": version,\n    \"thr\": threshold,\n    \"subsig\": subsigs\n  };\n  let sTxn = {\n    \"msig\": msig,\n    \"txn\": txnForEncoding\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\n\n\nfunction mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw ERROR_MULTISIG_MERGE_LESSTHANTWO;\n  }\n\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refSigAlgoTx = MultisigTransaction.from_obj_for_encoding(refSigTx.txn);\n  const refTxIDStr = refSigAlgoTx.txID().toString();\n  const from = address.encode(refSigTx.txn.snd);\n  let newSubsigs = refSigTx.msig.subsig;\n\n  for (let i = 0; i < multisigTxnBlobs.length; i++) {\n    let unisig = encoding.decode(multisigTxnBlobs[i]);\n    let unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n\n    if (unisigAlgoTxn.txID().toString() !== refTxIDStr) {\n      throw ERROR_MULTISIG_MERGE_MISMATCH;\n    } // check multisig has same preimage as reference\n\n\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    }\n\n    let preimg = {\n      \"version\": unisig.msig.v,\n      \"threshold\": unisig.msig.thr,\n      \"pks\": unisig.msig.subsig.map(subsig => {\n        return subsig.pk;\n      })\n    };\n\n    if (from !== address.encode(address.fromMultisigPreImg(preimg))) {\n      throw ERROR_MULTISIG_MERGE_WRONG_PREIMAGE;\n    } // now, we can merge\n\n\n    newSubsigs = unisig.msig.subsig.map((uniSubsig, index) => {\n      let current = newSubsigs[index];\n\n      if (current.s) {\n        if (uniSubsig.s && Buffer.compare(uniSubsig.s, current.s) !== 0) {\n          // mismatch\n          throw ERROR_MULTISIG_MERGE_SIG_MISMATCH;\n        }\n\n        return {\n          \"pk\": current.pk,\n          \"s\": current.s\n        };\n      } else if (uniSubsig.s) {\n        return {\n          \"pk\": current.pk,\n          \"s\": uniSubsig.s\n        };\n      }\n\n      return current;\n    });\n  }\n\n  let msig = {\n    \"v\": refSigTx.msig.v,\n    \"thr\": refSigTx.msig.thr,\n    \"subsig\": newSubsigs\n  };\n  let sTxn = {\n    \"msig\": msig,\n    \"txn\": refSigTx.txn\n  };\n  return new Uint8Array(encoding.encode(sTxn));\n}\n\nmodule.exports = {\n  MultisigTransaction,\n  mergeMultisigTransactions,\n  createMultisigTransaction,\n  ERROR_MULTISIG_MERGE_LESSTHANTWO,\n  ERROR_MULTISIG_MERGE_MISMATCH,\n  ERROR_MULTISIG_MERGE_WRONG_PREIMAGE,\n  ERROR_MULTISIG_MERGE_SIG_MISMATCH\n};","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"const address = require(\"./encoding/address\");\n\nconst encoding = require(\"./encoding/encoding\");\n\nconst nacl = require(\"./nacl/naclWrappers\");\n\nconst utils = require(\"./utils/utils\");\n\nconst base32 = require('hi-base32');\n\nconst ALGORAND_TRANSACTION_LENGTH = 52;\nconst ALGORAND_MIN_TX_FEE = 1000; // version v5\n\n/**\n * Transaction enables construction of Algorand transactions\n * */\n\nclass Transaction {\n  constructor({\n    from,\n    to,\n    fee,\n    amount,\n    firstRound,\n    lastRound,\n    note,\n    genesisID,\n    genesisHash,\n    closeRemainderTo,\n    voteKey,\n    selectionKey,\n    voteFirst,\n    voteLast,\n    voteKeyDilution,\n    type = \"pay\",\n    flatFee = false\n  }) {\n    this.name = \"Transaction\";\n    this.tag = Buffer.from([84, 88]); // \"TX\"\n\n    from = address.decode(from);\n    if (to !== undefined) to = address.decode(to);\n    if (closeRemainderTo !== undefined) closeRemainderTo = address.decode(closeRemainderTo);\n    if (genesisHash === undefined) throw Error(\"genesis hash must be specified and in a base64 string.\");\n    genesisHash = Buffer.from(genesisHash, 'base64');\n    if (amount !== undefined && (!Number.isSafeInteger(amount) || amount < 0)) throw Error(\"Amount must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(fee) || fee < 0) throw Error(\"fee must be a positive number and smaller than 2^53-1\");\n    if (!Number.isSafeInteger(firstRound) || firstRound < 0) throw Error(\"firstRound must be a positive number\");\n    if (!Number.isSafeInteger(lastRound) || lastRound < 0) throw Error(\"lastRound must be a positive number\");\n\n    if (note !== undefined) {\n      if (note.constructor !== Uint8Array) throw Error(\"note must be a Uint8Array.\");\n    } else {\n      note = new Uint8Array(0);\n    }\n\n    if (voteKey !== undefined) {\n      voteKey = Buffer.from(voteKey, \"base64\");\n    }\n\n    if (selectionKey !== undefined) {\n      selectionKey = Buffer.from(selectionKey, \"base64\");\n    }\n\n    Object.assign(this, {\n      from,\n      to,\n      fee,\n      amount,\n      firstRound,\n      lastRound,\n      note,\n      genesisHash,\n      genesisID,\n      closeRemainderTo,\n      voteKey,\n      selectionKey,\n      voteFirst,\n      voteLast,\n      voteKeyDilution,\n      type\n    }); // Modify Fee\n\n    if (!flatFee) {\n      this.fee *= this.estimateSize();\n    } // If suggested fee too small and will be rejected, set to min tx fee\n\n\n    if (this.fee < ALGORAND_MIN_TX_FEE) {\n      this.fee = ALGORAND_MIN_TX_FEE;\n    }\n  }\n\n  get_obj_for_encoding() {\n    if (this.type == \"pay\") {\n      let txn = {\n        \"amt\": this.amount,\n        \"fee\": this.fee,\n        \"fv\": this.firstRound,\n        \"lv\": this.lastRound,\n        \"note\": Buffer.from(this.note),\n        \"rcv\": Buffer.from(this.to.publicKey),\n        \"snd\": Buffer.from(this.from.publicKey),\n        \"type\": \"pay\",\n        \"gen\": this.genesisID,\n        \"gh\": this.genesisHash\n      }; // parse close address\n\n      if (this.closeRemainderTo !== undefined) txn.close = Buffer.from(this.closeRemainderTo.publicKey); // allowed zero values\n\n      if (!txn.note.length) delete txn.note;\n      if (!txn.amt) delete txn.amt;\n      if (!txn.fee) delete txn.fee;\n      if (!txn.gen) delete txn.gen;\n      return txn;\n    } else if (this.type == \"keyreg\") {\n      let txn = {\n        \"fee\": this.fee,\n        \"fv\": this.firstRound,\n        \"lv\": this.lastRound,\n        \"note\": Buffer.from(this.note),\n        \"snd\": Buffer.from(this.from.publicKey),\n        \"type\": this.type,\n        \"gen\": this.genesisID,\n        \"gh\": this.genesisHash,\n        \"votekey\": this.voteKey,\n        \"selkey\": this.selectionKey,\n        \"votefst\": this.voteFirst,\n        \"votelst\": this.voteLast,\n        \"votekd\": this.voteKeyDilution\n      }; // allowed zero values\n\n      if (!txn.note.length) delete txn.note;\n      if (!txn.fee) delete txn.fee;\n      if (!txn.gen) delete txn.gen;\n      return txn;\n    }\n  }\n\n  static from_obj_for_encoding(txnForEnc) {\n    let txn = Object.create(this.prototype);\n    txn.name = \"Transaction\";\n    txn.tag = Buffer.from([84, 88]); // \"TX\"\n\n    txn.genesisID = txnForEnc.gen;\n    txn.genesisHash = Buffer.from(txnForEnc.gh);\n    txn.type = txnForEnc.type;\n    txn.fee = txnForEnc.fee;\n    txn.firstRound = txnForEnc.fv;\n    txn.lastRound = txnForEnc.lv;\n    txn.note = new Uint8Array(txnForEnc.note);\n    txn.from = address.decode(address.encode(new Uint8Array(txnForEnc.snd)));\n\n    if (txnForEnc.type === \"pay\") {\n      txn.amount = txnForEnc.amt;\n      txn.to = address.decode(address.encode(new Uint8Array(txnForEnc.rcv)));\n      if (txnForEnc.close !== undefined) txn.closeRemainderTo = address.decode(address.encode(txnForEnc.close));\n    } else if (txnForEnc.type === \"keyreg\") {\n      txn.voteKey = Buffer.from(txnForEnc.votekey);\n      txn.selectionKey = Buffer.from(txnForEnc.selkey);\n      txn.voteKeyDilution = txnForEnc.votekd;\n      txn.voteFirst = txnForEnc.votefst;\n      txn.voteLast = txnForEnc.votelst;\n    }\n\n    return txn;\n  }\n\n  estimateSize() {\n    // Generate random key\n    let key = nacl.keyPair();\n    return this.signTxn(key.secretKey).length;\n  }\n\n  bytesToSign() {\n    let encodedMsg = this.toByte();\n    return Buffer.from(utils.concatArrays(this.tag, encodedMsg));\n  }\n\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  } // returns the raw signature\n\n\n  rawSignTxn(sk) {\n    const toBeSigned = this.bytesToSign();\n    const sig = nacl.sign(toBeSigned, sk);\n    return Buffer.from(sig);\n  }\n\n  signTxn(sk) {\n    // construct signed message\n    let sTxn = {\n      \"sig\": this.rawSignTxn(sk),\n      \"txn\": this.get_obj_for_encoding()\n    };\n    return new Uint8Array(encoding.encode(sTxn));\n  }\n\n  txID() {\n    const en_msg = encoding.encode(this.get_obj_for_encoding());\n    const gh = Buffer.from(utils.concatArrays(this.tag, en_msg));\n    return base32.encode(nacl.genericHash(gh)).slice(0, ALGORAND_TRANSACTION_LENGTH);\n  }\n\n}\n\nmodule.exports = {\n  Transaction\n};","map":null,"metadata":{},"sourceType":"script"}